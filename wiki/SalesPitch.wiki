#summary One-page "sales pitch"

=american fuzzy lop: one-page "sales pitch"=

In a hurry? There are several fairly decent reasons to give `afl-fuzz` a try:

  * <b>It is pretty sophisticated.</b> It's an instrumentation-guided genetic fuzzer capable of <a href='http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html'>synthesizing complex file semantics</a> in a wide range of non-trivial targets, lessening the need for purpose-built, syntax-aware tools.

  * <b>It has street smarts.</b> It is built around a range of <a href='http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html'>carefully researched</a>, high-gain test case preprocessing and fuzzing strategies rarely employed with comparable rigor in other fuzzing frameworks. As a result, it <a href='https://code.google.com/p/american-fuzzy-lop/wiki/TrophyCase'>finds real bugs</a>.

  * <b>It is fast.</b> Thanks to its low-level compile-time instrumentation and <a href='http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html'>other optimizations</a>, the tool offers near-native fuzzing speeds against common real-world targets.

  * <b>It's rock solid.</b> Compared to other instrumentation- or solver-based fuzzers, it has remarkably few failure modes. It also comes with robust troubleshooting capabilities and user-friendly error messages that guide you through any potential hiccups.

  * <b>No assembly is required.</b> In contrast to most other fuzzers, the tool requires essentially no effort to configure and fine-tune. Even if you wanted to, you will find virtually no knobs to tweak.

  * <b>It's chainable to other tools.</b> The fuzzer generates superior, compact <a href='http://lcamtuf.coredump.cx/afl_demo/'>test corpuses</a> that can serve as a seed for more specialized processes and testing frameworks.

Want to try it out? Check out the <a href='https://code.google.com/p/american-fuzzy-lop/wiki/AflDoc'>documentation</a> or grab the <a href='http://lcamtuf.coredump.cx/afl.tgz'>source code</a> right away.