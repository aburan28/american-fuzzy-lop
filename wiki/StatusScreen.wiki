#summary Tips for understanding the status screen

=american fuzzy lop: understanding the status screen=

When running `afl-fuzz`, the status screen should look roughly the following way:

{{{
>>> afl-fuzz 0.25b (gzip) <<<

Queue cycle: 1

    Overall run time : 0 days, 0 hrs, 8 min, 38.27 sec
      Problems found : 0 crashes (0 unique), 37 hangs (6 unique)
       Last new path : 0 days, 0 hrs, 5 min, 5.56 sec ago
   Last unique crash : none seen yet

In-depth stats:

      Cycle progress : 3/98+0 done (3.06%), 0 skipped
       Path topology : 2 levels, 95 pending, 0 latent, 0 variable
       Current stage : interest 16/8, 9700/10.9k done (88.34%)
    Execution cycles : 532.6k (1027.73 per second)
      Bitmap density : 2758 tuples seen (8.42%), 2.11 bits/tuple
  Fuzzing efficiency : path = 182.11, crash = 0.00, hang = 11.26 ppm

     Bit flip yields : 65/19.0k, 9/19.0k, 4/19.0k
    Byte flip yields : 0/2380, 5/2376, 1/2368
  Arithmetics yields : 12/152.3k, 0/44.4k, 0/16.4k
    Known int yields : 3/21.0k, 2/31.9k, 1/44.3k
  Havoc stage yields : 20/90.0k, 0/0
}}}

This page provides an overview for each of the displayed stats.

==Queue cycle==

This counter advances every time the fuzzer finishes going through all the interesting inputs and wraps around to the beginning of the queue. In general, any fuzzing job should complete at least one full queue cycle - and ideally, should be allowed to run considerably longer than that (few hundred cycles may be a good plan).

==Overall run time==

At the name implies, this field captures the overall run time for the entire fuzzing session. The fuzzing process continues until you press Ctrl-C. It is common to leave fuzzing jobs running for days, weeks, or months; the output directory can be accessed to investigate any potential finds on an ongoing basis.

==Problems found==

This line counts the number of crashes and timeouts encountered during the fuzzing process.

In addition to simply counting all faults, the fuzzer tries to identify duplicates by calculating a hash of the execution path that led to the fault condition. This is usually very reliable for crashes, but may inflate the number of unique hangs, especially when aggressive timeouts are in place.

==Last new path==

This line shows the time elapsed since the discovery of a previously unseen execution path. The parameter is useful for deciding when to end the fuzzing process: if the number of queue cycles is increasing steadily but no new paths are being identified for several days, it may be time to give up.

On the flip side, if this field reads "none seen yet" for more than a couple seconds after starting a completely new instrumented fuzzing job, chances are, something is horribly wrong: for example, the binary may be invoked incorrectly and never actually see the input generated by afl.

==Last unique crash==

This field displays the time elapsed since the discovery of any previously unseen crashes. It provides a quick visual confirmation for new finds.

==Cycle progress==

The field tracks the overall progress through a single queue cycle. The first number correspond to the number of processed input test cases, while the second represents the current total, broken into cases that are still considered worthwhile, and ones that were obsoleted by better coverage in later finds. The total should be gradually increasing as additional "interesting" inputs are discovered during the fuzzing process and added to the pile.

The last value indicates the number of inputs skipped due to persistently recurring timeouts.

==Path topology==

The first value describes the generational distance between the initial inputs (level 1) and the most distant unique test case generated so far. The second one indicates the number of newly discovered inputs that have not gone through any fuzzing yet.

The "latent" value keeps track of the number of more elusive execution paths that were discovered after completing the initial pass of the queue.

Finally, the last parameter in this line describes the number of inputs that seemed to produce unstable execution paths during the calibration phase. Such behavior may be caused by randomness intentionally built into the fuzzed library, or due to the use of uninitialized memory in presence of sources of entropy such as ASLR. These paths are denoted with a `-variable` suffix in the output directory; while not necessarily indicative of a security problem, the entries may warrant additional investigation later on.

==Current stage==

Shows the name of the current fuzzing strategy applied to a particular input, along with the number of completed executions and the expected total. The current stages are:

  * `calibration` - a pre-fuzzing stage where the execution path is examined to detect anomalies.

  * `bitflip L/S` - deterministic bit flip. There are L bits toggled at any given time, walking the input file at S-bit increments. The current L/S variants are: 1/1, 2/1, 4/1, 8/8, 16/8, 32/8.

  * `arith L/8` - deterministic arithmetics. The fuzzer tries to subtract or add small integers to 8-, 16-, and 32-bit values. The steopver is always 8 bits.

  * `interest L/8` - deterministic value overwrite. The fuzzer has a list of known "interesting" 8-, 16-, and 32-bit values to try. The stepover is 8 bits.

  * `havoc` - a sort-of-fixed-length cycle with stacked random tweaks. The operations attempted during this stage include bit flips, overwrites with random and "interesting" integers, block deletion, and block duplication.

  * `splice` - a last-resort strategy that kicks in after a full queue cycle with no new paths. It is equivalent to havoc, except that it first splices together two random inputs from the queue at some arbitrarily selected midpoint.

The first stages are executed only once per every new input, and have a run time proportional to the size of the input file. The "havoc" stage is repeated until `Ctrl-C` is hit; the proportion of time dedicated to each input is dynamically scaled depending on recorded coverage, program execution speed, fuzzing yields, and so on.

==Execution cycles==

Provides a total counter of `execve()` calls performed so far and keeps track of the average number of execs per second across the entire fuzzing process. Ideally, this should be several thousand or so; if it's lower than 100, the fuzzing process will be quite a drag.

Note that the display is refreshed roughly once per 100 executions.

==Bitmap density==

This value monitors the health of the injected instrumentation. If the value remains very low, the coverage achieved during the fuzzing process may be inadequate. This may be because the starting input file is not valid; because there are strong checksums guarding the data; or because the instrumentation does not extend to the library that actually parses the data. Another less sinister explanation is that the program is just very simple and there isn't much to test.

Tuple coverage in the vicinity of 5-10% is ideal.

==Fuzzing efficiency==

This field describes the average frequency of new paths, unique crashes, and unique hangs, per one million `execve()` calls. It offers some comparative insight into the ease of fuzzing the current input format, and the robustness of the tested code.

==Per-stage yields==

These lines document the number of new paths and crashes (but not hangs)  contributed by each of the implemented fuzzing strategies. It is meant mostly to prove or disprove the utility of each of the implemented fuzzing strategies.