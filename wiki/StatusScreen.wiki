#summary Tips for understanding the status screen

=american fuzzy lop: understanding the status screen=

When running `afl-fuzz`, the status screen should look roughly the following way:

{{{
>>> afl-fuzz 0.25b (gzip) <<<

Queue cycle: 1

    Overall run time : 0 days, 0 hrs, 8 min, 38.27 sec
      Problems found : 0 crashes (0 unique), 37 hangs (6 unique)
       Last new path : 0 days, 0 hrs, 5 min, 5.56 sec ago
   Last unique crash : none seen yet

In-depth stats:

      Cycle progress : 3/98+0 done (3.06%), 0 skipped
       Path topology : 2 levels, 95+0 pending, 0 latent, 0 variable
       Current stage : interest 16/8, 9700/10.9k done (88.34%)
    Execution cycles : 532.6k (1027.73 per second)
      Bitmap density : 2758 tuples seen (8.42%), 2.11 bits/tuple
  Fuzzing efficiency : path = 182.11, crash = 0.00, hang = 11.26 ppm

     Bit flip yields : 65/19.0k, 9/19.0k, 4/19.0k
    Byte flip yields : 0/2380, 5/2376, 1/2368
  Arithmetics yields : 12/152.3k, 0/44.4k, 0/16.4k
    Known int yields : 3/21.0k, 2/31.9k, 1/44.3k
  Havoc stage yields : 20/90.0k, 0/0
}}}

This page provides an overview for each of the displayed stats.

==Queue cycle==

This counter advances every time the fuzzer finishes going through all the interesting inputs and wraps around to the beginning of the queue. In general, any fuzzing job should complete at least one full queue cycle - and ideally, should be allowed to run considerably longer than that; 100+ cycles is a good plan.

==Overall run time==

At the name implies, this field captures the overall run time for the entire fuzzing session. The fuzzing process continues until you press Ctrl-C. It is common to leave fuzzing jobs running for days, weeks, or months; the output directory can be accessed to investigate any potential finds on an ongoing basis.

==Problems found==

This line counts the number of crashes and timeouts encountered during the fuzzing process.

In addition to simply counting all faults, the fuzzer tries to identify duplicates by calculating a hash of the execution path that led to the fault condition. This is usually very reliable for crashes, but may inflate the number of unique hangs depending on where exactly the scheduler decides to preempt the fuzzed binary. If you're seeing tons of timeouts, consider using the `-t` option on future runs.

==Last new path==

This line shows the time elapsed since the discovery of a previously unseen execution path. The parameter is useful for deciding when to end the fuzzing process: if the number of queue cycles is increasing steadily but no new paths are being identified for days or weeks, it may be time to give up.

On the flip side, if this field reads "none seen yet" for more than a couple seconds after starting a completely new instrumented fuzzing job, chances are, something is horribly wrong: for example, the binary may be invoked incorrectly and never actually see the input generated by afl. The fuzzer will try to visually warn you about that.

==Last unique crash==

This field displays the time elapsed since the discovery of any previously unseen crashes. It provides a quick visual confirmation for new finds.

==Cycle progress==

The field tracks the overall progress through a single queue cycle. Consider it just a fairly bad progress bar. 

The first number corresponds to the number of processed input test cases, while the second represents the current total, expressed as a sum of the entries that the fuzzer still considers genuinely interesting (and will spend more time on), and the ones that have been obsoleted by better finds.

The last value indicates the number of inputs skipped halfway through due to persistently recurring timeouts; ideally, this should be rare.

==Path topology==

Your original inputs are considered to be "level 1" test cases; the test cases derived by mutating them are "level 2"; "level 3" is formed by mutating level 2 test cases; and so on. 

In this spirit, the first value in this line reflects the maximum depth of a test case generated so far; it is an interesting proxy for how much mileage you're getting out of afl versus a non-guided fuzzer.

The second one indicates the number of newly discovered inputs that have not gone through any fuzzing yet, broken down into "interesting" and "redundant" ones. It's best to let a fuzzing job run long enough so that both values are zero.

The third parameter ("latent paths") keeps track of the number of more elusive execution paths that were discovered only after completing the initial pass of the queue. Again, it's mostly a proxy for how afl fares compared to non-guided tools.

Finally, the last parameter in this line describes the number of inputs that seemed to produce unstable execution paths during the calibration phase. Such behavior may be caused by randomness intentionally built into the fuzzed library, or due to the use of uninitialized memory in presence of sources of entropy such as ASLR. These paths are denoted with a `+var` suffix in the output directory; while not necessarily indicative of a security problem, the entries may warrant additional investigation later on.

==Current stage==

Shows the name of the current fuzzing strategy applied to a particular input, along with the number of completed executions and the expected total. The current stages are:

  * `calibration` - a pre-fuzzing stage where the execution path is examined to detect anomalies.

  * `bitflip L/S` - deterministic bit flip. There are L bits toggled at any given time, walking the input file at S-bit increments. The current L/S variants are: 1/1, 2/1, 4/1, 8/8, 16/8, 32/8.

  * `arith L/8` - deterministic arithmetics. The fuzzer tries to subtract or add small integers to 8-, 16-, and 32-bit values. The steopver is always 8 bits.

  * `interest L/8` - deterministic value overwrite. The fuzzer has a list of known "interesting" 8-, 16-, and 32-bit values to try. The stepover is 8 bits.

  * `havoc` - a sort-of-fixed-length cycle with stacked random tweaks. The operations attempted during this stage include bit flips, overwrites with random and "interesting" integers, block deletion, and block duplication.

  * `splice` - a last-resort strategy that kicks in after a full queue cycle with no new paths. It is equivalent to havoc, except that it first splices together two random inputs from the queue at some arbitrarily selected midpoint.

The first stages are executed only once per every new input, and have a run time proportional to the size of the input file. The "havoc" and "splice" stages are repeated until `Ctrl-C` is hit; the proportion of time dedicated to each input is dynamically scaled depending on recorded coverage, program execution speed, fuzzing yields, and so on.

==Execution cycles==

Provides a total counter of `execve()` calls performed so far and keeps track of the average number of execs per second across the entire fuzzing process. Ideally, this should be over 1,000; if it's lower than 100, the fuzzing process will be quite a drag. The fuzzer will try to warn you about that.

Note that the display is refreshed roughly once per 100 executions.

==Bitmap density==

This value monitors the health of the injected instrumentation. If the value remains very low, the coverage achieved during the fuzzing process may be inadequate. This may be because the starting input file is not valid; because there are strong checksums guarding the data; or because the instrumentation does not extend to the library that actually parses the data. Another less sinister explanation is that the program is just very simple and there isn't much to test.

Tuple coverage in the vicinity of 5-20% is typical and probably ideal.

==Fuzzing efficiency==

This field describes the average frequency of new paths, unique crashes, and unique hangs, per one million `execve()` calls. It offers some comparative insight into the ease of fuzzing the current input format, and the robustness of the tested code.

==Per-stage yields==

These lines document the number of new paths and crashes (but not hangs)  contributed by each of the implemented fuzzing strategies. It is meant mostly to prove or disprove the utility of each of the implemented fuzzing strategies.