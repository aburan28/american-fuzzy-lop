#summary Tips for understanding the status screen

=american fuzzy lop: understanding the status screen=

When running `afl-fuzz`, the status screen should look roughly the following way:

{{{
afl-fuzz 0.23b
--------------

Queue cycle: 1

    Overall run time : 0 days, 0 hrs, 8 min, 38.27 sec
      Problems found : 0 crashes (0 unique), 37 hangs (6 unique)
       Last new path : 0 days, 0 hrs, 5 min, 5.56 sec ago
   Last unique crash : none seen yet

In-depth stats:

     Execution paths : 3+0/98 done (3.06%), 0 variable, 2 levels
       Current stage : interest 16/8, 9700/10980 done (88.34%)
    Execution cycles : 532639 (1027.73 per second)
      Bitmap density : 2758 tuples seen (8.42%)
  Fuzzing efficiency : path = 182.11, crash = 0.00, hang = 11.26 ppm

     Bit flip yields : 65/19040, 9/19036, 4/19028
    Byte flip yields : 0/2380, 5/2376, 1/2368
  Arithmetics yields : 12/152320, 0/44499, 0/16480
    Known int yields : 3/21006, 2/31938, 1/44352
  Havoc stage yields : 20/90000 (0 latent paths)
}}}

This page provides an overview for each of the displayed stats.

==Queue cycle==

This counter advances every time the fuzzer finishes going through all the interesting inputs and wraps around to the beginning of the queue. In general, any fuzzing job should complete at least one full queue cycle - and ideally, should be allowed to run considerably longer than that.

==Overall run time==

At the name implies, this field captures the overall run time for the entire fuzzing session. The fuzzing process continues until you press Ctrl-C. It is common to leave fuzzing jobs running for days, weeks, or months; the output directory can be accessed to investigate any potential finds on an ongoing basis.

==Problems found==

This line counts the number of crashes and timeouts encountered during the fuzzing process.

In addition to simply counting all faults, the fuzzer tries to identify duplicates by calculating a hash of the execution path that led to the fault condition. This is usually very reliable for crashes, but may inflate the number of unique hangs, especially when aggressive timeouts are in place.

==Last new path==

This line shows the time elapsed since the discovery of a previously unseen execution path. The parameter is useful for deciding when to end the fuzzing process: if the number of queue cycles is increasing steadily but no new paths are being identified for several days, it may be time to give up.

==Last unique crash==

This field displays the time elapsed since the discovery of any previously unseen crashes. It provides a quick visual confirmation for new finds.

==Execution paths==

The field tracks the overall progress through a single queue cycle. The first number represents the number of successfully fuzzed inputs taken from the queue, while the second one shows the number of inputs abandoned due to timeouts. The third figure shows the overall size of the input queue; it should be gradually increasing as additional "interesting" inputs are discovered during the fuzzing process and added to the pile.

The next parameter in this line describes the number of inputs that seemed to produce unstable execution paths during the calibration phase. Such behavior may be caused by randomness intentionally built into the fuzzed library, or due to the use of uninitialized memory in presence of sources of entropy such as ASLR. These paths are denoted with a `-variable` suffix in the output directory; while not necessarily indicative of a security problem, the entries may warrant additional investigation later on.

Finally, the last variable describes the generational distance between the initial inputs (level 1) and the most distant unique test case generated so far.

==Current stage==

Shows the name of the current fuzzing strategy applied to a particular input, along with the number of completed executions and the expected total. The current stages are:

  * `calibration` - a pre-fuzzing stage where the execution path is examined to detect anomalies.

  * `bitflip L/S` - deterministic bit flip. There are L bits toggled at any given time, walking the input file at S-bit increments. The current L/S variants are: 1/1, 2/1, 4/1, 8/8, 16/8, 32/8.

  * `arith L/8` - deterministic arithmetics. The fuzzer tries to subtract or add small integers to 8-, 16-, and 32-bit values. The steopver is always 8 bits.

  * `interest L/8` - deterministic value overwrite. The fuzzer has a list of known "interesting" 8-, 16-, and 32-bit values to try. The stepover is 8 bits.

  * `havoc` - a sort-of-fixed-length cycle with stacked random tweaks. The operations attempted during this stage include bit flips, overwrites with random and "interesting" integers, block deletion, and block duplication.

The first stages are executed only once per every new input, and have a run time proportional to the size of the input file. The "havoc" stage is repeated until `Ctrl-C` is hit; the proportion of time dedicated to each input is dynamically scaled depending on recorded coverage, program execution speed, fuzzing yields, and so on.

==Execution cycles==

Provides a total counter of `execve()` calls performed so far and keeps track of the average number of execs per second across the entire fuzzing process. Ideally, this number should exceed 500; if it's lower than 100, the fuzzing process will be quite a drag.

Note that the display is refreshed roughly once per 100 executions.

==Bitmap density==

This value monitors the health of the injected instrumentation; if the number remains very low, the coverage achieved during the fuzzing process may be inadequate (or the program may be very simple). This may be because the starting input file is not valid; because there are strong checksums guarding the data; or because the instrumentation does not extend to the library that actually parses the data.

Figures in the vicinity of 10-30% are ideal.

==Fuzzing efficiency==

This field describes the average frequency of new paths, unique crashes, and unique hangs, per one million `execve()` calls. It offers some comparative insight into the ease of fuzzing the current input format, and the robustness of the tested code.

==Per-stage yields==

These lines document the number of new paths and crashes (but not hangs)  contributed by each of the implemented fuzzing strategies. It is meant mostly to prove or disprove the utility of each of the implemented fuzzing strategies.

The "latent paths" statistic for the havoc stage keeps track of the number of execution paths that were discovered after completing the initial pass of the queue.