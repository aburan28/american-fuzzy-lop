#summary Tips for understanding the status screen

=american fuzzy lop: understanding the status screen=

When running `afl-fuzz`, the status screen should look roughly the following way:

{{{
afl-fuzz 0.20b
--------------

Queue cycle: 1

    Overall run time : 0 days, 0 hrs, 2 min, 34.00 sec
      Problems found : 2 crashes (1 unique), 67 hangs (13 unique)
       Last new path : 0 days, 0 hrs, 0 min, 36.58 sec ago
   Last unique crash : 0 days, 0 hrs, 2 min, 23.58 sec ago

In-depth stats:

     Execution paths : 1+0/99 done (1.01%)
       Current stage : interest 32/8, 30600/33490 done (91.37%)
    Execution cycles : 162476 (1055.02 per second)
      Bitmap density : 3542 tuples seen (10.81%)
  Fuzzing efficiency : path = 609.32, crash = 6.15, hang = 80.01 ppm

     Bit flip yields : 64/10272, 17/10270, 6/10266
    Byte flip yields : 1/1284, 4/1282, 2/1278
    Known int yields : 4/11556, 4/47510, 3/33390
  Havoc stage yields : 7/5000 (0 latent paths)
}}}

This page provides an overview for each of the displayed stats.

==Queue cycle==

This counter advances every time the fuzzer finishes going through all the interesting inputs and wraps around to the beginning of the queue. In general, any fuzzing job should complete at least one queue cycle - and ideally, much more.

==Overall run time==

At the name implies, this field captures the overall run time for the entire fuzzing session.

==Problems found==

This line counts the number of crashes and timeouts encountered during the fuzzing process.

The fuzzer tries to identify duplicates by calculating a hash of the execution path. This is usually very reliable for crashes, but can be hit-and-miss for timeouts.

==Last new path==

This line shows the time elapsed since the discovery of any previously unseen execution paths. This is useful for deciding when to end the fuzzing process: if no new paths have been identified for several days, you might have reached a plateau.

==Last unique crash==

This field displays the time elapsed since the discovery of any previously unseen crashes. It provides a quick visual confirmation of new finds, and helps you decide when to end the fuzzing process.

==Execution paths==

The field tracks the overall progress through a single queue cycle. The first number represents the number of successfully fuzzed inputs, the second one shows the number of inputs abandoned due to timeouts. The third figure shows the overall size of the input queue; it should gradually increase as additional "interesting" inputs are discovered during the fuzzing process.

==Current stage==

Shows the name of the current fuzzing strategy applied to a particular input, along with the number of completed executions and the expected total.

==Execution cycles==

Provides a total counter of `execve()` calls and indicates the average number of execs per second. Ideally, this number should exceed 1000; if it's lower than 100, the fuzzing process will be quite a drag.

==Bitmap density==

This value monitors the health of the injected instrumentation; if it remains very low (under 10%), the coverage achieved during the fuzzing process may be inadequate. Figures in the vicinity of 20-40% are ideal.

==Fuzzing efficiency==

This field describes the average frequency of new paths, unique crashes, and unique hangs, per one million `execve()` calls. It offers some comparative insight into the ease of fuzzing the current input format, and the robustness of the tested code.

==Per-stage yields==

These lines document the number of new paths, crashes, or hangs contributed by each of the implemented fuzzing strategies. It is meant mostly as a QA tool for the fuzzer itself.

The "latent paths" statistic for the havoc stage keeps track of the number of execution paths that were discovered after completing the initial pass of the queue.